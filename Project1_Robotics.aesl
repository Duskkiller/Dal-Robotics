<!DOCTYPE aesl-source>
<network>


<!--list of global events-->


<!--list of constants-->
<constant value="0" name="STOPPED"/>
<constant value="1" name="FORWARD"/>
<constant value="-1" name="LEFT"/>
<constant value="1" name="RIGHT"/>
<constant value="4" name="LEFT1"/>
<constant value="5" name="RIGHT1"/>
<constant value="6" name="LOST"/>
<constant value="7" name="LOST1"/>
<constant value="8" name="FORWARD1"/>
<constant value="450" name="TARGET"/>
<constant value="750" name="TABLE"/>
<constant value="250" name="THRESHOLD"/>
<constant value="2500" name="TURNINGP"/>
<constant value="400" name="TURN_PERIOD"/>
<constant value="450" name="TARGET1"/>
<constant value="200" name="TARGET2"/>
<constant value="250" name="TURNTARGET"/>
<constant value="69" name="AVOID"/>
<constant value="9" name="NORMAL"/>


<!--show keywords state-->
<keywords flag="true"/>


<!--node thymio-II-->
<node nodeId="1" name="thymio-II">var state = STOPPED
var direction
motor.left.target = 0
motor.right.target = 0
timer.period[0] = 0
timer.period[1] = 0

sub forward
	motor.left.target = TARGET
	motor.right.target = TARGET
	call leds.top(0,255,0)#green
sub stopped
	motor.left.target = 0
	motor.right.target = 0
	call leds.top(0,0,0)#no colour
sub right #soft right
	motor.left.target = TARGET
	motor.right.target = TARGET-200
	call leds.top(255, 179, 76)#orange
sub left #soft left
	motor.left.target = TARGET-200
	motor.right.target = TARGET
	call leds.top(0,0,255)#blue
sub hardRight
	motor.left.target = TARGET
	motor.right.target = -TARGET
	call leds.top(255, 255, 76)#yellow
sub hardLeft
	motor.left.target = TARGET * direction
	motor.right.target = -TARGET * direction
sub lost
	motor.left.target = TARGET 

################END OF STATES######################################
onevent button.forward
	state = NORMAL
	callsub forward
onevent button.backward
	state = STOPPED
	callsub stopped

onevent prox 
	if  state !=STOPPED then
		if  (state == NORMAL) then
			if  (prox.ground.delta[1] > TABLE) then
				direction = RIGHT
				callsub right
			elseif  (prox.ground.delta[0] > TABLE) then
				direction = LEFT
				callsub left
			elseif (prox.ground.delta[0] > TABLE and prox.ground.delta[1] > TABLE)  then
				callsub lost
			elseif (prox.ground.delta[0] &lt; TABLE and prox.ground.delta[1] &lt; TABLE) then
				direction = FORWARD #this might be bugged
				callsub forward
			end
		end
	end
	if prox.horizontal[2]>TURNINGP-1500 then
		state = AVOID
		callsub hardRight
		if  prox.ground.delta[0] > THRESHOLD+50 and prox.ground.delta[1] > THRESHOLD+100 			then
			timer.period[0]=TURN_PERIOD
		end
	elseif prox.horizontal[1]>TURNINGP then
		state = AVOID
		callsub hardRight
		if prox.ground.delta[0] > THRESHOLD+100 and prox.ground.delta[1] > THRESHOLD +100 		then
			timer.period[0] = TURN_PERIOD-50
		end
	elseif prox.horizontal[3]>TURNINGP then
		state = AVOID
		callsub hardRight
		if  prox.ground.delta[0]>THRESHOLD+100 and prox.ground.delta[1]>THRESHOLD+100 				then
			timer.period[0] = TURN_PERIOD+150	
		end
	elseif prox.horizontal[0]>TURNINGP-1500 then
		state = AVOID
		callsub hardRight
		if  prox.ground.delta[0]> THRESHOLD+100 and prox.ground.delta[1]>THRESHOLD+100 				then
			timer.period[0] = TURN_PERIOD-100
		end
	end
onevent timer0
	if  state == AVOID then
		timer.period[1] = 0
		timer.period[0] = 0
		state = AVOID
		callsub hardLeft
	end</node>


</network>
